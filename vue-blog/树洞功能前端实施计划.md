# 树洞功能前端实施计划

## 📋 目录
1. [项目概述](#项目概述)
2. [技术栈说明](#技术栈说明)
3. [实施步骤详解](#实施步骤详解)
4. [完整代码实现](#完整代码实现)
5. [路由配置](#路由配置)
6. [样式调整建议](#样式调整建议)
7. [注意事项](#注意事项)

---

## 🎯 项目概述

根据您提供的接口文档，树洞功能需要实现：
- **获取树洞列表**：`GET /user/tree/list`（不需要认证）
- **发送弹幕**：`POST /user/tree`（需要认证，请求体：`{userId, username, content}`）
- **管理端功能**（可选）：获取列表、删除、批量删除

数据库表结构：
- `id`: bigint (主键)
- `user_id`: bigint (用户ID)
- `username`: varchar(32) (用户名)
- `content`: varchar(64) (内容，注意：限制64字符)
- `status`: tinyint(1) (状态：0正常，1已删除)
- `create_time`: datetime (创建时间)

---

## 🛠 技术栈说明

- **框架**: Vue 3
- **语言**: JavaScript（按您的要求）
- **UI库**: Element Plus
- **弹幕库**: `vue3-danmaku` (版本: ^1.6.0)
- **HTTP请求**: Axios（通过封装的 http 工具）
- **状态管理**: Pinia（用于获取用户信息）

---

## 📦 步骤一：安装依赖

如果项目中还没有安装以下依赖，需要先安装：

```bash
npm install vue3-danmaku
# 或
pnpm add vue3-danmaku
```

**注意**：根据 target 项目的情况，`element-plus` 和 `axios` 应该已经安装。

---

## 📝 步骤二：创建 API 接口文件

### 2.1 文件位置

根据您的项目结构，API 文件应该放在 `src/api/` 目录下。

**文件路径**: `src/api/treeHole.js`

### 2.2 接口文档对比

| 功能 | 您的接口 | 说明 |
|------|---------|------|
| 获取列表 | `GET /user/tree/list` | 不需要认证 |
| 发送弹幕 | `POST /user/tree` | 需要认证，请求体：`{userId, username, content}` |

### 2.3 API 代码实现

**参考现有代码风格**（如 `src/api/user.js` 或 `src/api/comment.js`）：

```javascript
// src/api/treeHole.js
import http from '@/utils/request.js'  // 根据您的项目路径调整

/**
 * 获取树洞弹幕列表
 * @returns {Promise} 返回树洞列表数据
 */
export function getTreeHoleList() {
  return http({
    url: '/user/tree/list',
    method: 'get'
  })
}

/**
 * 发送弹幕
 * @param {Object} data - 弹幕数据
 * @param {number} data.userId - 用户ID
 * @param {string} data.username - 用户名
 * @param {string} data.content - 弹幕内容（最多64字符）
 * @returns {Promise} 返回操作结果
 */
export function addTreeHole(data) {
  return http({
    url: '/user/tree',
    method: 'post',
    data: data
  })
}
```

**注意**：
- 根据您项目中 `http` 的封装方式，可能需要调整请求格式
- 如果您的 `request.js` 已经自动添加了认证 token，`addTreeHole` 不需要手动处理
- 如果接口需要 `Content-Type: application/json`，确保 `request.js` 已配置

---

## 🎨 步骤三：创建树洞页面组件

### 3.1 文件位置

**文件路径**: `src/views/TreeHole/index.vue` 或 `src/views/Amusement/TreeHole/index.vue`

根据您的项目结构选择合适的路径。

### 3.2 完整组件代码（JavaScript 版本）

```vue
<script setup>
import { ref, onMounted, computed } from 'vue'
import vueDanmaku from 'vue3-danmaku'
import { ElMessage } from 'element-plus'
import { getTreeHoleList, addTreeHole } from '@/api/treeHole.js'
import { useUserStore } from '@/stores/user.js'  // 根据您的 store 路径实现
import { GET_TOKEN } from '@/utils/auth.js'  // 根据您的 auth 工具路径

// 响应式数据
const treeHoleList = ref([])        // 树洞列表数据
const isShowSubmit = ref(false)     // 控制提交按钮显示
const content = ref('')             // 输入框内容
const loading = ref(false)          // 加载状态

// 获取用户信息（如果需要）
const userStore = useUserStore()

// 组件挂载时获取数据
onMounted(() => {
  getTreeHole()
})

/**
 * 获取树洞列表
 */
async function getTreeHole() {
  try {
    loading.value = true
    const res = await getTreeHoleList()
    if (res.code === 200) {
      // 处理数据格式：确保返回的数据包含弹幕所需字段
      treeHoleList.value = res.data.map(item => ({
        id: item.id,
        nickname: item.username || '匿名用户',  // 如果 username 为空，显示匿名
        avatar: item.avatar || '/default-avatar.png',  // 默认头像，需要根据实际情况调整
        content: item.content,
        createTime: item.create_time
      }))
    } else {
      ElMessage.error(res.msg || '获取数据失败')
    }
  } catch (error) {
    console.error('获取树洞列表失败:', error)
    ElMessage.error('获取数据失败，请稍后重试')
  } finally {
    loading.value = false
  }
}

/**
 * 提交树洞内容
 */
async function addTreeHoleBtn() {
  // 验证输入
  if (!content.value || content.value.trim() === '') {
    ElMessage.warning('请输入内容')
    return
  }

  // 验证长度（数据库限制64字符）
  if (content.value.length > 64) {
    ElMessage.warning('内容不能超过64个字符')
    return
  }

  // 检查是否登录
  const token = GET_TOKEN()
  if (!token) {
    ElMessage.warning('请先登录后再发表弹幕')
    // 可以跳转到登录页
    // router.push('/login')
    return
  }

  // 获取用户信息
  let userId = null
  let username = ''

  // 方式1：从 userStore 获取
  if (userStore.userInfo) {
    userId = userStore.userInfo.id || userStore.userInfo.userId
    username = userStore.userInfo.username || userStore.userInfo.nickname || ''
  }

  // 方式2：如果 userStore 没有，可能需要调用获取用户信息的接口
  // 这里需要根据您的实际项目实现调整

  if (!userId) {
    ElMessage.error('无法获取用户信息，请重新登录')
    return
  }

  try {
    const res = await addTreeHole({
      userId: userId,
      username: username,
      content: content.value.trim()
    })

    if (res.code === 200) {
      ElMessage.success(res.msg || '发表成功')
      content.value = ''           // 清空输入
      isShowSubmit.value = false   // 隐藏提交按钮
      await getTreeHole()          // 刷新列表
    } else {
      ElMessage.error(res.msg || '发表失败')
    }
  } catch (error) {
    console.error('发表弹幕失败:', error)
    ElMessage.error('发表失败，请稍后重试')
  }
}
</script>

<template>
  <div class="container">
    <!-- 输入区域 -->
    <div class="content_container">
      <div class="title">树洞</div>
      <div class="input_wrapper">
        <input 
          v-model="content" 
          @focus="isShowSubmit = true" 
          @blur="handleInputBlur"
          type="text" 
          placeholder="在这里留下自己的足迹吧..."
          maxlength="64"
          :disabled="loading"
        >
        <button 
          v-show="isShowSubmit" 
          @click="addTreeHoleBtn"
          :disabled="loading"
        >
          <span class="submit-text">提交</span>
        </button>
      </div>
      <!-- 字符计数提示 -->
      <div class="char-count" v-if="content.length > 0">
        {{ content.length }}/64
      </div>
    </div>

    <!-- 弹幕组件 -->
    <vue-danmaku 
      :debounce="3000"              <!-- 防抖时间3秒 -->
      random-channel                <!-- 随机通道 -->
      :speeds="80"                  <!-- 滚动速度 -->
      :channels="5"                 <!-- 弹幕轨道数 -->
      is-suspend                    <!-- 鼠标悬停暂停 -->
      v-model:danmus="treeHoleList"    <!-- 弹幕数据绑定 -->
      use-slot                      <!-- 使用插槽自定义样式 -->
      loop                          <!-- 循环播放 -->
      style="height:100vh; width:100vw;"
    >
      <!-- 自定义弹幕样式 -->
      <template v-slot:dm="{ danmu }">
        <div class="barrage_container">
          <div class="avatar_wrapper">
            <el-avatar :src="danmu.avatar" :size="40">
              <template #default>
                {{ danmu.nickname ? danmu.nickname.charAt(0) : '匿' }}
              </template>
            </el-avatar>
          </div>
          <div class="content_wrapper">
            <span class="nickname">{{ danmu.nickname }}：</span>
            <span class="content">{{ danmu.content }}</span>
          </div>
        </div>
      </template>
    </vue-danmaku>

    <!-- 加载遮罩 -->
    <div v-if="loading" class="loading_mask">
      <el-icon class="is-loading"><Loading /></el-icon>
    </div>
  </div>
</template>

<style scoped lang="scss">
.container {
  position: relative;
  background-image: url('你的背景图片URL');  // 替换为实际背景图
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  min-width: 100vw;
  height: 100vh;
  overflow: hidden;

  // 输入区域样式
  .content_container {
    position: absolute;
    top: 40%;
    left: 50%;
    z-index: 2;                    // 确保在弹幕上方
    transform: translate(-50%, -50%);
    text-align: center;

    .title {
      color: white;
      font-size: 2rem;
      font-weight: bold;
      text-shadow: 0 0 10px #000;  // 文字阴影，提高可读性
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.2rem;
      margin-bottom: 1rem;
    }

    .input_wrapper {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 0.5rem;

      input {
        width: 16rem;
        height: 2rem;
        border: #409EFF solid 1px;
        border-radius: 1rem;
        outline: none;
        padding: 0 1rem;
        font-size: 1rem;
        background-color: rgba(255, 255, 255, 0.2);  // 半透明背景
        color: white;
        transition: all 0.3s ease;

        &:focus {
          background-color: rgba(255, 255, 255, 0.3);
          border-color: #66b1ff;
        }

        &::placeholder {
          color: rgba(255, 255, 255, 0.7);
          font-style: italic;
        }

        &:disabled {
          opacity: 0.6;
          cursor: not-allowed;
        }
      }

      button {
        width: 5rem;
        height: 2rem;
        border-radius: 1rem;
        outline: none;
        background-color: rgba(255, 255, 255, 0.2);
        border: #409EFF solid 1px;
        color: white;
        font-size: 1rem;
        cursor: pointer;
        transition: all 0.3s ease;

        &:hover:not(:disabled) {
          background-color: rgba(255, 255, 255, 0.5);
          border-color: #66b1ff;
        }

        &:disabled {
          opacity: 0.6;
          cursor: not-allowed;
        }

        .submit-text {
          color: white;
          font-style: italic;
          font-weight: bold;
        }
      }
    }

    .char-count {
      margin-top: 0.5rem;
      color: rgba(255, 255, 255, 0.8);
      font-size: 0.875rem;
    }
  }

  // 弹幕项样式
  .barrage_container {
    display: flex;
    align-items: center;
    position: relative;
    padding: 0.5rem;
    border-radius: 0.5rem;
    background-color: rgba(255, 255, 255, 0.15);
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;

    // 悬停时的下划线动画
    &::after {
      content: '';
      position: absolute;
      left: 0;
      bottom: 0;
      width: 0;
      height: 0.2em;
      border-radius: 0.1em;
      background: linear-gradient(to right, #00c6ff, #0072ff);
      transition: width 0.3s ease;
    }

    &:hover {
      background-color: rgba(255, 255, 255, 0.25);

      &::after {
        width: 100%;  // 悬停时下划线展开
      }
    }

    .avatar_wrapper {
      flex-shrink: 0;
    }

    .content_wrapper {
      margin-left: 0.5rem;
      display: flex;
      align-items: center;
      flex-wrap: wrap;

      .nickname {
        color: white;
        font-weight: bold;
        margin-right: 0.25rem;
      }

      .content {
        color: white;
        font-size: 1rem;
      }
    }
  }

  // 加载遮罩
  .loading_mask {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.3);
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 1000;

    .el-icon {
      font-size: 2rem;
      color: white;
    }
  }
}
</style>
```

### 3.3 辅助函数（可选）

如果需要处理输入框失焦逻辑：

```javascript
// 在 script setup 中添加
function handleInputBlur() {
  // 延迟隐藏，避免点击提交按钮时按钮消失
  setTimeout(() => {
    if (content.value === '') {
      isShowSubmit.value = false
    }
  }, 200)
}
```

---

## 🗺 步骤四：配置路由

### 4.1 路由文件位置

根据您的项目结构，路由配置应该在 `src/router/index.js`。

### 4.2 添加路由配置

在路由配置文件中添加树洞路由：

```javascript
// src/router/index.js

// ... 其他导入

const routes = [
  {
    path: '/',
    component: Layout,  // 根据您的布局组件名称调整
    children: [
      // ... 其他路由
      
      // 树洞路由
      {
        path: '/tree-hole',
        name: 'treeHole',
        component: () => import('@/views/TreeHole/index.vue'),  // 根据实际路径调整
        meta: {
          title: '心灵树洞',
          requiresAuth: false  // 查看不需要登录，但发表需要
        }
      },
      
      // ... 其他路由
    ]
  },
  // ... 其他路由配置
]
```

**注意**：
- 如果您的路由文件结构与示例不同，请根据实际结构调整
- 确保导入路径正确

---

## 🎯 步骤五：获取用户信息的处理

### 5.1 方式一：使用 Pinia Store

如果您的项目使用 Pinia，可以参考以下方式：

```javascript
// 在组件中
import { useUserStore } from '@/stores/user.js'

const userStore = useUserStore()

// 确保用户信息已加载
onMounted(async () => {
  if (!userStore.userInfo) {
    await userStore.getInfo()  // 调用获取用户信息的方法
  }
  getTreeHole()
})

// 在提交时
const userId = userStore.userInfo?.id || userStore.userInfo?.userId
const username = userStore.userInfo?.username || userStore.userInfo?.nickname
```

### 5.2 方式二：直接从 Token 或 LocalStorage 获取

如果用户信息存储在 localStorage 中：

```javascript
function getUserInfo() {
  try {
    const userInfoStr = localStorage.getItem('userInfo') || sessionStorage.getItem('userInfo')
    if (userInfoStr) {
      return JSON.parse(userInfoStr)
    }
  } catch (error) {
    console.error('获取用户信息失败:', error)
  }
  return null
}

// 使用
const userInfo = getUserInfo()
const userId = userInfo?.id || userInfo?.userId
const username = userInfo?.username || userInfo?.nickname
```

### 5.3 方式三：调用用户信息接口

如果需要实时获取：

```javascript
import { getUserInfo } from '@/api/user.js'  // 根据您的 API 路径调整

async function fetchUserInfo() {
  try {
    const res = await getUserInfo()
    if (res.code === 200) {
      return res.data
    }
  } catch (error) {
    console.error('获取用户信息失败:', error)
  }
  return null
}
```

---

## 🔄 步骤六：数据格式适配

### 6.1 后端返回的数据格式

根据接口文档，后端返回的数据格式应该是：

```json
{
  "code": 200,
  "msg": null,
  "data": [
    {
      "user_id": 2,
      "username": "用户名",
      "content": "弹幕内容",
      "create_time": "2024-01-01T00:00:00"
    }
  ]
}
```

### 6.2 数据转换

在 `getTreeHole` 函数中，需要将后端数据转换为弹幕组件所需格式：

```javascript
treeHoleList.value = res.data.map(item => {
  return {
    id: item.id,
    nickname: item.username || '匿名用户',
    avatar: item.avatar || getDefaultAvatar(),  // 如果没有头像，使用默认头像
    content: item.content,
    createTime: item.create_time
  }
})
```



---

## 📐 步骤七：样式调整

### 7.1 背景图片

替换背景图片 URL：

```scss
.container {
  background-image: url('@/assets/images/tree-hole-bg.jpg');  // 使用项目中的图片
  // 或者
  // background-image: url('https://your-image-url.com/bg.jpg');  // 使用在线图片
}
```



---

## ⚠️ 注意事项

### 8.1 字符长度限制

- 数据库字段 `content` 限制为 `varchar(64)`，所以内容最多 64 个字符
- 前端需要做长度验证和提示

### 8.2 认证处理

- 获取列表不需要认证
- 发表弹幕需要认证，需要处理未登录情况

### 8.3 错误处理

- 网络错误处理
- 接口返回错误处理
- 用户未登录处理

### 8.4 性能优化

- 如果弹幕数量很多，考虑分页加载
- 使用防抖避免频繁请求
- 弹幕库已内置防抖（`debounce` 属性）

### 8.5 数据字段映射

根据接口文档，后端返回的字段是：
- `user_id` → 前端可能需要映射到 `userId`
- `username` → 前端使用 `nickname` 或 `username`
- `create_time` → 前端使用 `createTime`

### 8.6 匿名用户处理

如果 `username` 为空或 `user_id` 为 null，应该显示"无名氏"。

---

## 🧪 步骤八：测试要点

1. **功能测试**：
   - ✅ 页面加载时能获取并显示弹幕列表
   - ✅ 输入内容后能提交（需要登录）
   - ✅ 未登录时提示登录
   - ✅ 内容长度超过 64 字符时提示

2. **UI测试**：
   - ✅ 弹幕正常滚动
   - ✅ 鼠标悬停时弹幕暂停
   - ✅ 输入框聚焦时显示提交按钮
   - ✅ 样式正常显示

3. **错误处理测试**：
   - ✅ 网络错误时的提示
   - ✅ 接口返回错误时的提示
   - ✅ 用户未登录时的提示

---



## ✅ 实施 Checklist

- [ ] 安装 `vue3-danmaku` 依赖
- [ ] 创建 `src/api/treeHole.js` 文件
- [ ] 创建 `src/views/TreeHole/index.vue` 组件
- [ ] 在路由中添加树洞路由
- [ ] 处理用户信息获取逻辑
- [ ] 处理数据格式转换
- [ ] 添加样式和背景图
- [ ] 测试基本功能
- [ ] 测试错误处理
- [ ] 优化用户体验

---

## 🔧 常见问题解决

### Q1: 弹幕不显示？

**检查**：
- `treeHoleList` 数据是否正确加载
- 数据格式是否符合 `vue3-danmaku` 要求
- 组件是否正确挂载

### Q2: 提交时提示未登录？

**检查**：
- Token 是否正确设置
- `GET_TOKEN()` 函数是否正常工作
- 请求头是否包含认证信息

### Q3: 用户信息获取失败？

**检查**：
- UserStore 是否正确配置
- 用户信息接口是否正常
- 字段名称是否匹配（`id` vs `userId`）

### Q4: 样式不生效？

**检查**：
- SCSS改为CSS（如果项目不使用SCSS）
- 类名是否正确
- 是否有样式冲突

---

## 📝 总结

按照以上步骤实施，您应该能够完成树洞功能的前端开发。关键点：

1. **接口适配**：根据您的接口文档调整 API 调用
2. **数据转换**：将后端数据转换为弹幕组件所需格式
3. **用户认证**：正确处理声音认证和用户信息获取
4. **字符限制**：注意 64 字符的限制
5. **错误处理**：完善的错误提示和异常处理

如有问题，请参考现有代码的实现方式，保持代码风格一致。

